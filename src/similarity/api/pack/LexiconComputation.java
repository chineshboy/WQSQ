package similarity.api.pack;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import serialize.api.pack.KBDoc;

import com.hp.hpl.jena.graph.NodeFactory;
import com.hp.hpl.jena.rdf.model.Model;
import com.hp.hpl.jena.rdf.model.Property;
import com.hp.hpl.jena.rdf.model.RDFNode;
import com.hp.hpl.jena.rdf.model.Resource;
import com.hp.hpl.jena.rdf.model.Statement;
import com.hp.hpl.jena.tdb.TDBFactory;

public class LexiconComputation {

	private static final String datasetpath = "D:\\workspace\\WhyNot\\tdb_type_infoprop";		//local TDB storage path
	private static final Model ontModel  = TDBFactory.createDataset(datasetpath).getDefaultModel();		//load model from local TDB
	private static Map<String, String> kbUnigrams;
	private static Map<String, String> kbBigrams;
	public static final float alpha = 0.5f;
	public static final float beta = 0.5f;
	public static final float mius = (float)1/3;
	public static final float miuo = (float)1/3;
	
	public LexiconComputation() {
		//KBDoc kbDoc = new KBDoc();	 	//construct a KBDoc Object
		//serializeKBDoc(kbDoc);			//serialize the KBDoc Object
        try {
            FileInputStream fis = new FileInputStream("kbDoc.out");		//the serialized file is generated by function serializeKBDoc
            ObjectInputStream ois = new ObjectInputStream(fis);
            KBDoc kbDoc = (KBDoc) ois.readObject();			//read the serialized object
            kbUnigrams = kbDoc.getKBUnigrams();
            kbBigrams = kbDoc.getKBBigrams();
            ois.close();	
        } catch (Exception ex) {
            ex.printStackTrace();
        }
	}
	
	public Map<String, String> constructKBUnigramsTable() {
		Map<String, String> KBUnigrams = new HashMap<String, String>();	//entity document
		for (Iterator<Statement> i = ontModel.listStatements(); i.hasNext();){
			Statement c = (Statement) i.next();
			updateOccurrence(KBUnigrams, c.getSubject().toString());	//add the triple(entity occurs as a subject) to the document
			if(c.getObject().isResource()) {
				updateOccurrence(KBUnigrams, c.getObject().toString());
			}
		}
		return KBUnigrams;
	}
	
	public Map<String, String> constructKBBigramsTable() {
		Map<String, String> KBBigrams = new HashMap<String, String>();	//entity document
		for (Iterator<Statement> i = ontModel.listStatements(); i.hasNext();){
			Statement c = (Statement) i.next();
			String spPair = c.getSubject().toString() + "\t" + c.getPredicate().toString();		//subject-predicate pair as a bigram
			updateOccurrence(KBBigrams, spPair);
			if(c.getObject().isResource()) {
				String poPair = c.getPredicate().toString() + "\t" + c.getObject().toString();	//subject-predicate pair as a bigram
				updateOccurrence(KBBigrams, poPair);
				String soPair = c.getSubject().toString() + "\t" + c.getObject().toString();	//subject-predicate pair as a bigram
				updateOccurrence(KBBigrams, soPair);
			}
		}
		return KBBigrams;
	}
	
	//Entity document(the statements collection where the entity occurs as a subject or an object)
	public ArrayList<Statement> constructEntityDoc(String uri) {
		ArrayList<Statement> entityDoc = new ArrayList<Statement>();	//entity document
		Resource s = ontModel.getResource(uri);
		RDFNode o = ontModel.getRDFNode(NodeFactory.createURI(uri));
		for (Iterator<Statement> i = ontModel.listStatements(s, null, (RDFNode)null); i.hasNext();){
			Statement c = (Statement) i.next();
			entityDoc.add(c);	//add the triple(entity occurs as a subject) to the document
		}
		for (Iterator<Statement> i = ontModel.listStatements(null, null, o); i.hasNext();){
			Statement c = (Statement) i.next();
			entityDoc.add(c);	//add the triple(entity occurs as an object) to the document
		}		
		//System.out.println("the number of Entity Document statements:" + entityDoc.size());
		return entityDoc;
	}

	//Entity unigrams table(subjects and objects in entity doc with its occurrences)
	public Map<String, String> constructEntityUnigrams(String uri) {
		Map<String, String> entityUnigramsTable = new HashMap<String, String>();		//store entity unigrams and its occurrences in entity doc
		Resource s = ontModel.getResource(uri);			//entity as subject
		RDFNode o = ontModel.getRDFNode(NodeFactory.createURI(uri));	//entity as object
		int uriNum = 0;
		for (Iterator<Statement> i = ontModel.listStatements(s, null, (RDFNode)null); i.hasNext();){
			Statement c = (Statement) i.next();
			uriNum++;	//update the occurrence of the parameter entity
			if(c.getObject().isResource()) {
				updateOccurrence(entityUnigramsTable, c.getObject().toString());		//update the occurrence of entity unigram(as a object in the entity doc) table
			}
		}
		for (Iterator<Statement> i = ontModel.listStatements(null, null, o); i.hasNext();){
			Statement c = (Statement) i.next();
			uriNum++;	//update the occurrence of the parameter entity
			updateOccurrence(entityUnigramsTable, c.getSubject().toString());		//update the occurrence of entity unigram(as a subject in the entity doc) table
		}
		entityUnigramsTable.put(uri, String.valueOf(uriNum));			//add the entity and its occurrences to the entity unigrams table
		//System.out.println("the number of Entity unigrams:" + entityUnigramsTable.size());
		return entityUnigramsTable;
	}
	
	//Entity bigrams table(subject-predicate pairs and predicate-object pairs in entity doc with its occurrences)
	public Map<String, String> constructEntityBigrams(String uri) {
		Map<String, String> entityBigramsTable = new HashMap<String, String>();			//store entity bigrams and its occurrences in entity doc
		Resource s = ontModel.getResource(uri);
		RDFNode o = ontModel.getRDFNode(NodeFactory.createURI(uri));
		for (Iterator<Statement> i = ontModel.listStatements(s, null, (RDFNode)null); i.hasNext();){
			Statement c = (Statement) i.next();
			String item = c.getSubject() + "\t" + c.getPredicate();
			updateOccurrence(entityBigramsTable, item);		//update the occurrence of entity bigram(as subject-predicate pair in the entity doc) table
		}
		for (Iterator<Statement> i = ontModel.listStatements(null, null, o); i.hasNext();){
			Statement c = (Statement) i.next();
			String item = c.getPredicate() + "\t" + c.getObject();
			updateOccurrence(entityBigramsTable, item);		//update the occurrence of entity bigram(as predicate-object pair in the entity doc) table
		}		
		//System.out.println("the number of Entity bigrams:" + entityBigramsTable.size());
		return entityBigramsTable;
	}
	
	//Relation document(the statements collection where the relation occurs as a predicate)
	public ArrayList<Statement> constructRelationDoc(String uri) {
		ArrayList<Statement> relationDoc = new ArrayList<Statement>();
		Property p = ontModel.getProperty(uri);
		for (Iterator<Statement> i = ontModel.listStatements(null, p, (RDFNode)null); i.hasNext();){
			Statement c = (Statement) i.next();
			relationDoc.add(c);			//add the triples(the uri is predicate) to the relation document
		}
		//System.out.println("the number of Relation Document statements:" + relationDoc.size());
		return relationDoc;
	}
	
	//Relation unigrams(entities occur as subject in the relation doc)
	public Map<String, String> constructSubRelationUnigrams(String relation) {
		Map<String, String> relationUnigramsTable = new HashMap<String, String>();	//store relation unigrams and its occurrences in entity doc
		Property p = ontModel.getProperty(relation);
		for (Iterator<Statement> i = ontModel.listStatements(null, p, (RDFNode)null); i.hasNext();){
			String item = ((Statement) i.next()).getSubject().toString();
			updateOccurrence(relationUnigramsTable, item);			//update the occurrence of unigram(as subject) in the relation doc
		}
		return relationUnigramsTable;
	}

	//Relation unigrams(entities occur as object in the relation doc)
	public Map<String, String> constructObjRelationUnigrams(String relation) {
		Map<String, String> relationUnigramsTable = new HashMap<String, String>();	//store relation unigrams and its occurrences in entity doc
		Property p = ontModel.getProperty(relation);
		for (Iterator<Statement> i = ontModel.listStatements(null, p, (RDFNode)null); i.hasNext();){
			Statement c = (Statement) i.next();
			if(c.getObject().isResource()) {
				String item = c.getObject().toString();
				updateOccurrence(relationUnigramsTable, item);		//update the occurrence of unigram(as object) in the relation doc
			}
		}
		return relationUnigramsTable;
	}

	//Relation bigrams
	public Map<String, String> constructRelationBigrams(String relation) {
		Map<String, String> relationBigramsTable = new HashMap<String, String>();	//store relation bigrams and its occurrences in entity doc
		Property p = ontModel.getProperty(relation);
		for (Iterator<Statement> i = ontModel.listStatements(null, p, (RDFNode)null); i.hasNext();){
			Statement c = (Statement) i.next();
			if(c.getObject().isResource()) {
				String item = c.getSubject().toString() + "\t" + c.getObject().toString();	
				updateOccurrence(relationBigramsTable, item);
			}
		}
		//System.out.println("the number of relation bigrams:" + relationBigrams.size());		
		return relationBigramsTable;
	} 
	
	//the language model of unigrams
	public float UnigramsLM(String uri, Map<String, String> UnigramsTable) {
		int uriNum = UnigramsTable.size();		//the occurrences of uri in entity/relation doc
		int count1 = 0;		//record the frequencies of occurrences of all the unigrams in the entity/relation document
		int count2 = 0; 	//record the frequencies of occurrences of all the unigrams in the KB document
		if(UnigramsTable.isEmpty()) {
			//System.out.println("There are no unigrams of the entity.");
			return 0;
		}
		for(String unigram : UnigramsTable.keySet()) {
			count1 += Integer.parseInt(UnigramsTable.get(unigram));		//the occurrences of unigram in entity/relation doc
			count2 += Integer.parseInt(kbUnigrams.get(unigram));				//the occurrences of unigram in KB doc
		}
		//System.out.println("count1 = " + count1 + ", count2 = " + count2 + ", unigrams number :" + UnigramsTable.size());
		float unigramLM = alpha * ((float)uriNum / count1) + (1 - alpha) * ((float)uriNum / count2);	//language model of unigram, stands for its average frequencies of occurrence in entity doc and KB doc
		//System.out.println(unigramLM);
		return unigramLM;
	}
	
	//the language model of bigrams
	public float BigramsLM(String uri, Map<String, String> BigramsTable) {
		int uriNum = BigramsTable.size();		//the occurrences of uri in entity/relation doc
		int count1 = 0;		//record the frequencies of occurrences of all the bigrams in the entity/relation document
		int count2 = 0; 	//record the frequencies of occurrences of all the bigrams in the KB document
		if(BigramsTable.isEmpty()) {
			//System.out.println("There are no bigrams of the entity.");
			return 0;
		}
		for(String bigram : BigramsTable.keySet()) {
			count1 += Integer.parseInt(BigramsTable.get(bigram));	//the occurrences of unigram in entity/relation doc
			count2 += Integer.parseInt(kbBigrams.get(bigram));				//the occurrences of unigram in KB doc			
		}
		//System.out.println("count1 = " + count1 + ", count2 = " + count2 + ", bigrams number :" + BigramsTable.size());
		float bigramLM = alpha * ((float)uriNum / count1) + (1 - alpha) * ((float)uriNum / count2);			//language model of bigram, stands for its frequencies of occurrence in entity/relation doc and KB doc
		//System.out.println(bigramLM);
		return bigramLM;
	}
	
	//the language model of the entity
	public float constructEntityLM(String entity) {
		Map<String, String> entityUnigramsTable = constructEntityUnigrams(entity);		//entity unigrams table
		Map<String, String> entityBigramsTable = constructEntityBigrams(entity);		//entity bigrams table
		float entityLM = beta * UnigramsLM(entity, entityUnigramsTable) + (1 - beta) * BigramsLM(entity, entityBigramsTable);		//language model of entity, stands for its distribution in the whole data space
		return entityLM;
	}
	
	//the language model of the relation
	public float constructRelationLM(String relation) {
		Map<String, String> relationSubUnigramsTable = constructSubRelationUnigrams(relation);		//relation unigrams table
		Map<String, String> relationObjUnigramsTable = constructObjRelationUnigrams(relation);		//relation unigrams table
		Map<String, String> relationBigramsTable = constructRelationBigrams(relation);			//relation bigrams table
		float relationLM = mius * UnigramsLM(relation, relationSubUnigramsTable) + miuo * UnigramsLM(relation, relationObjUnigramsTable) + (1 - mius - miuo) * BigramsLM(relation, relationBigramsTable);		//language model of relationship, stands for its distribution in the whole data space
		return relationLM;
	}

	//update the occurrences of map(unigram/bigram table)
	public void updateOccurrence(Map<String, String> gramTable, String item) {
		if(gramTable.containsKey(item)) {	//if the unigram/bigram existed in the  gram table
			int number = Integer.parseInt(gramTable.get(item));	//get its occurrences
			number++;	//update its occurrence
			gramTable.remove(item);
			gramTable.put(item, String.valueOf(number));		//add the gram and updated occurrence value to the gram table
		}
		else {
			gramTable.put(item, String.valueOf(1));				//add a new bigram and its initialized occurrence(0) to the gram table
		}
	}
	
	public void serializeKBDoc(KBDoc kbDoc) {
        try {
            FileOutputStream fos = new FileOutputStream("kbDoc.out");
            ObjectOutputStream oos = new ObjectOutputStream(fos);
            oos.writeObject(kbDoc);
            //System.out.println("Serialized the KBDoc successfully.");
            oos.close();                        
        } catch (Exception ex) {  
        	ex.printStackTrace();  
        }
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		LexiconComputation lexiconCompu = new LexiconComputation();
		long start = System.currentTimeMillis();
		String entity = "http://dbpedia.org/resource/Abraham_Lincoln";  	//the uri of the interested entity
		String relation = "http://dbpedia.org/property/war";	//the uri of the interested relation
		float entityLM = lexiconCompu.constructEntityLM(entity);
		System.out.println("Entity LM Score is : " + entityLM);
		float relationLM = lexiconCompu.constructRelationLM(relation);
		System.out.println("Relation LM Score is : " + relationLM);
		long end = System.currentTimeMillis();
		System.out.println("Time : " + (end - start) + "ms");
	}
}
